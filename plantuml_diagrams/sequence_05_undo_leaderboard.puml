@startuml Undo and Leaderboard Sequence
title Sequence Diagram: Undo Move and Leaderboard

actor User
participant Browser
participant game.js as "Frontend\n(game.js)"
participant routes.api as "API Route\n(api.py)"
participant routes.game as "Game Route\n(game.py)"
participant routes.history as "History Route\n(history.py)"
participant Session as "Flask Session"
participant Game2048 as "Game Logic"
participant Database as "SQLite DB"
participant ScoreModel as "Score Model"
participant UserModel as "User Model"

== Undo Move ==
User -> Browser: Click "Undo" button
Browser -> game.js: handleUndo()
activate game.js
game.js -> routes.api: POST /api/undo
deactivate game.js
activate routes.api

routes.api -> routes.api: @login_required
routes.api -> Session: Check game_state
activate Session
Session --> routes.api: Game2048 instance or None
deactivate Session

alt No game state
  routes.api --> game.js: {ok: False, message: "Chưa khởi tạo trò chơi"}
else Game exists
  routes.api -> Session: load_game()
  activate Session
  Session --> routes.api: Game2048 instance
  deactivate Session
  
  routes.api -> Game2048: undo()
  activate Game2048
  
  alt No last_state
    Game2048 --> routes.api: {grid, score, moves}
  else Has last_state
    Game2048 -> Game2048: grid = last_state["grid"]
    Game2048 -> Game2048: score = last_state["score"]
    Game2048 -> Game2048: moves = last_state["moves"]
    Game2048 -> Game2048: game_over = False
    Game2048 -> Game2048: last_state = None
    Game2048 --> routes.api: {grid, score, moves}
  end
  deactivate Game2048
  
  routes.api -> Session: save_game(game)
  activate Session
  Session --> routes.api: Saved
  deactivate Session
  
  routes.api --> game.js: {ok: True, grid, score, moves, can_undo: False}
end
deactivate routes.api

game.js -> game.js: render(data)
game.js -> Browser: Update board
game.js -> game.js: updateUndoButton(canUndo)
Browser -> User: Show updated board
deactivate game.js

== Leaderboard ==
User -> Browser: Truy cập /leaderboard
Browser -> routes.game: GET /leaderboard
activate routes.game

routes.game -> Database: Query best scores per user
activate Database
Database -> Database: SELECT user_id, MAX(score) AS best_score
Database -> Database: GROUP BY user_id
Database -> Database: Subquery best_per_user
Database --> Database: Subquery created
Database

routes.game -> Database: JOIN scores, best_per_user, users
activate Database
Database -> Database: WHERE score = best_score
Database -> Database: ORDER BY score DESC, max_tile DESC, moves ASC, created_at ASC
Database -> Database: LIMIT 20
Database --> routes.game: Top 20 rows
deactivate Database

routes.game --> Browser: Render leaderboard.html\n{rows}
deactivate routes.game
Browser -> User: Display leaderboard
deactivate Browser

== Game History ==
User -> Browser: Truy cập /history
Browser -> routes.history: GET /history
activate routes.history

routes.history -> routes.history: Get page from request (default=1)
routes.history -> Database: Query Score by user_id
activate Database
Database -> Database: WHERE user_id = current_user.id
Database -> Database: ORDER BY created_at DESC
Database -> Database: Paginate (page, per_page=20)
Database --> routes.history: Pagination object
deactivate Database

routes.history -> Database: Count total games
activate Database
Database --> routes.history: total_games
deactivate Database

routes.history -> Database: SELECT MAX(score) WHERE user_id
activate Database
Database --> routes.history: best_score
deactivate Database

routes.history -> Database: SELECT MAX(max_tile) WHERE user_id
activate Database
Database --> routes.history: best_tile
deactivate Database

routes.history -> Database: SELECT AVG(score) WHERE user_id
activate Database
Database --> routes.history: avg_score
deactivate Database

routes.history -> Database: SELECT SUM(moves) WHERE user_id
activate Database
Database --> routes.history: total_moves
deactivate Database

routes.history -> routes.history: Build stats dict
routes.history --> Browser: Render game_history.html\n{scores, stats, pagination}
deactivate routes.history
Browser -> User: Display history + stats

== Save Score on Game Over ==
note over Browser,Database: This happens during game flow when game ends

routes.api -> Game2048: check_game_over()
activate Game2048
Game2048 -> Game2048: any_moves_left()
activate Game2048
Game2048 -> Game2048: Check empty cells
Game2048 -> Game2048: Check adjacent pairs
Game2048 --> routes.api: True/False
deactivate Game2048

alt No moves left
  Game2048 --> routes.api: {score, max_tile, moves}
else Has moves
  Game2048 --> routes.api: None
end
deactivate Game2048

routes.api -> routes.api: Check game_over response
alt Game over detected
  routes.api -> ScoreModel: Score(user_id, score, max_tile, moves)
  activate ScoreModel
  ScoreModel --> routes.api: Score instance
  deactivate ScoreModel
  
  routes.api -> Database: session.add(score_entry)
  routes.api -> Database: session.commit()
  activate Database
  Database --> routes.api: Score saved
  deactivate Database
  
  routes.api -> Session: Clear game_state
  activate Session
  Session --> routes.api: Cleared
  deactivate Session
  
  routes.api --> game.js: {game_over: {...}}
  game.js -> Browser: showGameOverOverlay()
end

deactivate routes.api

@enduml

